# BFS vs DFS 비교표

## 기본 특성 비교

| 특성 | BFS (너비 우선 탐색) | DFS (깊이 우선 탐색) |
|------|---------------------|-------------------|
| **탐색 순서** | 레벨(거리) 순서대로 | 한 방향으로 끝까지 |
| **자료구조** | 큐(Queue) | 스택(Stack) 또는 재귀 |
| **메모리 사용** | 많음 (한 레벨의 모든 노드 저장) | 적음 (현재 경로만 저장) |
| **구현 복잡도** | 상대적으로 복잡 | 상대적으로 간단 |
| **시간 복잡도** | O(V + E) | O(V + E) |

## 문제 유형별 사용 가이드

### 🎯 **BFS를 사용해야 하는 경우**

| 문제 유형 | 설명 | 대표 문제 |
|-----------|------|----------|
| **최단 경로** | 가중치가 없는 그래프에서 최단 경로 | 미로 찾기, 나이트의 이동 |
| **최소 이동 횟수** | 목표까지 최소 단계 구하기 | 숨바꼭질, 물통 문제 |
| **레벨별 탐색** | 각 레벨의 노드를 순서대로 처리 | 트리의 레벨별 순회 |
| **연결 요소 크기** | 연결된 컴포넌트의 최소 크기 | 섬의 개수, 연결 요소 |
| **상태 공간 탐색** | 상태 전이가 단계별로 이루어지는 경우 | 퍼즐 게임, 게임 상태 |

### 🎯 **DFS를 사용해야 하는 경우**

| 문제 유형 | 설명 | 대표 문제 |
|-----------|------|----------|
| **경로 탐색** | 모든 가능한 경로 찾기 | 미로의 모든 경로 |
| **사이클 검출** | 그래프에서 사이클 존재 확인 | 위상 정렬, 사이클 검출 |
| **백트래킹** | 해를 찾기 위한 시행착오 | N-Queen, 스도쿠 |
| **트리 구조** | 트리의 깊이 우선 처리 | 트리 순회, 부모-자식 관계 |
| **연결성 확인** | 두 노드가 연결되어 있는지 확인 | 그래프 연결성 |

## 구체적인 알고리즘 문제 예시

### 📍 **BFS 활용 문제**

| 백준 문제 | 문제명 | 이유 |
|-----------|--------|------|
| 1697 | 숨바꼭질 | 최소 시간(이동 횟수) 구하기 |
| 2178 | 미로 탐색 | 최단 경로 찾기 |
| 7576 | 토마토 | 동시에 퍼지는 현상 모델링 |
| 1926 | 그림 | 연결된 영역의 크기 구하기 |
| 2667 | 단지번호붙이기 | 각 단지의 집 개수 구하기 |

### 📍 **DFS 활용 문제**

| 백준 문제 | 문제명 | 이유 |
|-----------|--------|------|
| 11725 | 트리의 부모 찾기 | 트리 구조 파악 |
| 1012 | 유기농 배추 | 연결 요소 개수 구하기 |
| 2606 | 바이러스 | 연결된 컴퓨터 수 구하기 |
| 15649 | N과 M (1) | 순열 생성 (백트래킹) |
| 9663 | N-Queen | 백트래킹으로 해 찾기 |

## 메모리와 성능 고려사항

### 🔍 **메모리 사용량**

| 상황 | BFS | DFS |
|------|-----|-----|
| **넓고 얕은 그래프** | 많은 메모리 사용 ⚠️ | 적은 메모리 사용 ✅ |
| **좁고 깊은 그래프** | 적은 메모리 사용 ✅ | 스택 오버플로우 위험 ⚠️ |
| **균형 잡힌 트리** | 보통 | 보통 |

### 🔍 **성능 특성**

| 목적 | BFS | DFS |
|------|-----|-----|
| **최단 경로** | 보장됨 ✅ | 보장 안됨 ❌ |
| **모든 경로 탐색** | 비효율적 ❌ | 효율적 ✅ |
| **조기 종료** | 레벨별로 가능 | 깊이별로 가능 |

## 실제 코드 구현 패턴

### 🚀 **BFS 구현 패턴**

```java
Queue<Integer> queue = new LinkedList<>();
boolean[] visited = new boolean[n];
queue.offer(start);
visited[start] = true;

while (!queue.isEmpty()) {
    int current = queue.poll();
    // 현재 노드 처리
    
    for (int next : graph[current]) {
        if (!visited[next]) {
            visited[next] = true;
            queue.offer(next);
        }
    }
}
```

### 🚀 **DFS 구현 패턴**

```java
boolean[] visited = new boolean[n];

void dfs(int current) {
    visited[current] = true;
    // 현재 노드 처리
    
    for (int next : graph[current]) {
        if (!visited[next]) {
            dfs(next);
        }
    }
}
```

## 선택 기준 요약

### ✅ **BFS를 선택하는 경우**
- 최단 경로나 최소 이동 횟수가 필요할 때
- 레벨별로 처리해야 할 때
- 시작점에서 가까운 것부터 찾아야 할 때

### ✅ **DFS를 선택하는 경우**
- 모든 경로를 탐색해야 할 때
- 백트래킹이 필요할 때
- 메모리 사용량을 줄이고 싶을 때
- 트리 구조를 다룰 때

### 🤔 **둘 다 가능한 경우**
- 연결 요소의 개수 구하기
- 그래프의 연결성 확인
- 단순한 그래프 순회

이 표를 참고하여 문제의 특성에 맞는 알고리즘을 선택하세요!