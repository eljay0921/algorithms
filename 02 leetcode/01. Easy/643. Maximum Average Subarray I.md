# [643. Maximum Average Subarray I](https://leetcode.com/problems/maximum-average-subarray-i/)

Easy

You are given an integer array `nums` consisting of `n` elements, and an integer `k`.

Find a contiguous subarray whose **length is equal to** `k` that has the maximum average value and return *this value*. Any answer with a calculation error less than `10^-5` will be accepted.

 **n 요소로 구성된 정수 배열 번호와 정수 k가 주어집니다.**

**길이가 최대 평균 값을 갖는 k와 동일한 연속 서브 어레이를 찾아 이 값을 반환하십시오. 10^-5 미만의 계산 오류가있는 모든 답변이 수락됩니다.**

**Example 1:**

```
Input: nums = [1,12,-5,-6,50,3], k = 4
Output: 12.75000
Explanation: Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75
```

**Example 2:**

```
Input: nums = [5], k = 1
Output: 5.00000
```

 

**Constraints:**

- `n == nums.length`
- `1 <= k <= n <= 105`
- `-104 <= nums[i] <= 104`

---

Acceptance Rate

45.6%

---

# Solutions

## v1

```java
class Solution {
    public double findMaxAverage(int[] nums, int k) {
        
        double result = -Double.MAX_VALUE;
        for (int i = 0; i <= nums.length - k; i++) {

            int sum = 0;
            int temp = 0;
            while (temp < k) {
                sum += nums[i + temp++];
            }

            result = Math.max(result, sum);
        }

        return result / k;
    }
}
```

이 문제는 `Sliding Windows` 기법을 적용해야 한다. 그러나 일단 `v1`은 그냥 풀어본 것이다. 다행히 대부분의 test case에서 통과했지만, 역시 **시간 초과**로 마지막 2개의 case를 통과하지 못했다. 이제 `Sliding Windows`를 적용할 차례다.

그리고 처음에는 `double result = Double.MIN_VALUE`;를 적용했다가, `nums`에 담긴 **음수**에 대응하지 못해 위와 같이 수정한 상황이다. 

## v2 (Sliding Windows)

```java
class Solution {
    public double findMaxAverage(int[] nums, int k) {
        
        // 첫 번째 Window 세팅 
        double window = 0;
        for (int i = 0; i < k; i++) {
            window += nums[i];
        }

        // Window 이동
        double maxValue = window;
        for (int i = 0; i < nums.length - k; i++) {
            window = window - nums[i] + nums[k + i];
            maxValue = Math.max(maxValue, window);
        }

        return maxValue / k;
    }
}
```

`Sliding Windows` 문제도 처음 풀어봤는데, 기본적인 개념은 간단해 보인다. **창문(windows)**이 이동하듯, 앞의 요소를 제거함과 동시에 뒤의 요소를 추가한다. 이 덕분에 매번 `k`의 크기만큼 **반복하지 않아도 되어**서 시간 복잡도를 낮출 수 있다.

이번 문제에서는 최대 크기에서 평균 값을 찾는 과정이었으므로, **첫 번째 window를 최대 값으로** 세팅하고 시작하며, 문제에서 주어진 조건 "Any answer with a calculation error less than `10^-5` will be accepted."를 지킬 수 있도록 `double` 타입을 사용한 것이 주요한 내용이다. (부동 소수점 오차)