# [283. Move Zeroes](https://leetcode.com/problems/move-zeroes/)

**Easy**

Given an integer array `nums`, move all `0`'s to the end of it while maintaining the relative order of the non-zero elements.

**Note** that you must do this in-place without making a copy of the array.

**정수 배열의 숫자가 주어지면 0이 아닌 요소의 상대적 순서를 유지하면서 0을 모두 배열의 끝으로 이동합니다.**

**배열의 복사본을 만들지 않고 제자리에서 이 작업을 수행해야 한다는 점에 유의하세요.**

**Example 1:**

```
Input: nums = [0,1,0,3,12]
Output: [1,3,12,0,0]
```

**Example 2:**

```
Input: nums = [0]
Output: [0]
```

 

**Constraints:**

- `1 <= nums.length <= 104`
- `-231 <= nums[i] <= 231 - 1`

 

**Follow up:** Could you minimize the total number of operations done?

------

Acceptance Rate

62.9%

---

# Solutions

## v1

```java
class Solution {
    public void moveZeroes(int[] nums) {
        
        int write = 0;

        for (int read = 0; read < nums.length; read++) {
            int num = nums[read];
            if (num != 0) {
                nums[write++] = num;
            }
        }

        for (int i = write; i < nums.length; i++) {
            nums[i] = 0;
        }
    }
}
```

`two pointers` 방식으로 정말 단순하게 풀었다. 성능도 `2ms`로 충분히 빠르다. 그런데, 이 코드를 GPT에게 공유하니 조금이나마 개선할 수 있는 부분이 있었다. **뒤에 0을 채우는 부분**이 아쉬웠던 것이다.

## v2

```java
class Solution {
    public void moveZeroes(int[] nums) {
        
        int write = 0;

        for (int read = 0; read < nums.length; read++) {
            int num = nums[read];
            if (num != 0) {
                if (read != write) {
                    nums[read] = nums[write];
                    nums[write] = num;
                }
                write++;
            }
        }
    }
}
```

0이 아닐 때, `read`와 `write`를 바로 **스왑하는 방식**이다. 이러면 굳이 0을 채우는 후처리 작업이 필요하지 않다.