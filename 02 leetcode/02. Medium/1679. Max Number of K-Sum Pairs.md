# [1679. Max Number of K-Sum Pairs](https://leetcode.com/problems/max-number-of-k-sum-pairs/)

**Medium**

You are given an integer array `nums` and an integer `k`.

In one operation, you can pick two numbers from the array whose sum equals `k` and remove them from the array.

Return *the maximum number of operations you can perform on the array*.

**정수 배열 n과 정수 k가 주어집니다.**

**한 번의 연산으로 배열에서 합이 k와 같은 두 개의 숫자를 골라 배열에서 제거할 수 있습니다.**

**배열에서 수행할 수 있는 최대 연산 횟수를 반환합니다.**

**Example 1:**

```
Input: nums = [1,2,3,4], k = 5
Output: 2
Explanation: Starting with nums = [1,2,3,4]:
- Remove numbers 1 and 4, then nums = [2,3]
- Remove numbers 2 and 3, then nums = []
There are no more pairs that sum up to 5, hence a total of 2 operations.
```

**Example 2:**

```
Input: nums = [3,1,3,4,3], k = 6
Output: 1
Explanation: Starting with nums = [3,1,3,4,3]:
- Remove the first two 3's, then nums = [1,4,3]
There are no more pairs that sum up to 6, hence a total of 1 operation.
```

 

**Constraints:**

- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 109`
- `1 <= k <= 109`

---

Acceptance Rate

56.3%

---

# Solutions

처음에 무작정 `two pointers`를 적용하려 했더니 쉽게 풀리지 않았다. `nums`에서 이미 사용된 원소의 위치를 저장하고(`checked`) 처리해봤지만 계속 로직이 꼬였고, 코드가 지저분 해져 가독성이 좋지 않으니, 내가 짠 코드 스파게티에 내가 헷갈리기 시작했다. 

리셋. 이 문제에서 `nums`에 남은 숫자의 순서를 지켜야 한다는 요구사항은 없다. 그러므로 먼저 `nums`를 **정렬**하고 `two pointers`를 적용하면 더 쉽게 해결할 수 있다.

## v1 (sort + two pointers)

```java
import java.util.*;

class Solution {
    public int maxOperations(int[] nums, int k) {
                
        Arrays.sort(nums);

        int counter = 0;
        int left = 0;
        int right = nums.length - 1;

        while (left < right) {

            int sum = nums[left] + nums[right];
            if (sum < k) {
                left++;
            } else if (sum > k) {
                right--;
            } else {
                counter++;
                left++;
                right--;
            }
        }

        return counter;
    }
}
```

숫자를 **정렬한 상태이므로**, 두 숫자의 합이 target인 `k`보다 크다면 `right pointer`를 낮춰야 하고, 반대로 작다면 `left pointer`를 낮추면 된다. 매우 간단하게 풀렸으나, `Arrays.sort()`가 들어간 만큼 약간의 시간 복잡도가 추가되었음에도, 현재 submit 결과는 `18ms`로 꽤 빠른 속도다. (Beats **92.79%**)

## v2 (HashMap)

```java
import java.util.*;

class Solution {
    public int maxOperations(int[] nums, int k) {

        Map<Integer, Integer> map = new HashMap<>();
        int counter = 0;

        for (int i = 0; i < nums.length; i++) {

            int gap = k - nums[i];
            if (map.containsKey(gap) && map.get(gap) > 0) {
                counter++;
                map.put(gap, map.get(gap) - 1); // 사용했으니 count -1
            } else {
                map.put(nums[i], map.getOrDefault(nums[i], 0) + 1); // 처음 put이면 1, 아니면 +1
            }
        }

        return counter;
    }
}
```

`gemini`가 이게 더 빠를 거라고 알려줘서 적용해봤으나, 결과는 `39ms`로 `v1`에 비해 **2배 더 느린 속도**를 보여줬다. 아무래도 `two pointers`가 효율적인 알고리즘인 것도 있지만, 순차적인 배열 요소 접근이 **캐시 효율**을 좋게 만든 것으로 추정된다. 그에 반해 `Map`에 대한 접근은 비교적 캐시 효율이 떨어질 것이다. 

성능으로 보나, 코드의 가독성으로 보나 `v1`이 훨씬 낫다.