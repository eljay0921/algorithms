

# A -> B

> 실버 2

| 시간 제한 | 메모리 제한 | 제출  | 정답  | 맞힌 사람 | 정답 비율 |
| --------- | ----------- | ----- | ----- | --------- | --------- |
| 2 초      | 512 MB      | 72562 | 30278 | 23821     | 40.086%   |

## 문제

정수 A를 B로 바꾸려고 한다. 가능한 연산은 다음과 같은 두 가지이다.

- 2를 곱한다.
- 1을 수의 가장 오른쪽에 추가한다. 

A를 B로 바꾸는데 필요한 연산의 최솟값을 구해보자.

## 입력

첫째 줄에 A, B (1 ≤ A < B ≤ 109)가 주어진다.

## 출력

A를 B로 바꾸는데 필요한 연산의 최솟값에 1을 더한 값을 출력한다. 만들 수 없는 경우에는 -1을 출력한다.

​			 		

## 예제 입력 1 						

```
2 162
```

## 예제 출력 1 						

```
5
```

2 → 4 → 8 → 81 → 162

## 예제 입력 2 						

```
4 42
```

## 예제 출력 2 						

```
-1
```

## 예제 입력 3 						

```
100 40021
```

## 예제 출력 3 						

```
5
```

100 → 200 → 2001 → 4002 → 40021

---

# Solutions

## v1 (Greedy)

```java
import java.io.*;
import java.util.*;

public class Q16953 {
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int origin = Integer.parseInt(st.nextToken());
        int target = Integer.parseInt(st.nextToken());

        int count = 0;
        while (target > origin) {

            if (target % 2 == 0) {
                target /= 2;
                count++;
            } else if (target % 10 == 1) {
                target /= 10;
                count++;
            } else {
                count = -1;
                break;
            }

            if (target == origin) {
                break;
            }
        }

        count = (target == origin) ? count + 1 : -1;
        System.out.print(count);
    }

}

```

문제를 읽고 아이디어가 떠오르는 대로 풀었다. 다행히 사소한 실수 몇 가지를 수정하고 정상적으로 풀렸다. 속도도 `64ms`로 만족스럽다.

`target`이 될 숫자가 애초에 끝자리가 `1`이 아니거나, `2`로 나누어지지 않는다면 **해당 숫자에 도달할 수 없을 거라는 생각**으로 풀었다. `단순 구현`이라고 생각했는데, 이처럼 **최적의 선택이 최적해로 이어지는 풀이**가 바로 `Greedy`였다. 

반대로, 도달할 수 있는 선택지(가지)가 여러 개여서 다시 뒤돌아 가서 **탐색**을 한다던지, 현재의 선택이 최종 결과에 **불가능한 경우**인지 바로 판단할 수 없다면 `bfs`, `dfs`, `dp`, `backtracking `등의 전략이 필요할 것이다. 물론 그 외 다른 알고리즘이 솔루션일 수도 있다.



## v2 (bfs)

```java
import java.io.*;
import java.util.*;

public class Q16953 {
    // v2 (bfs)
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        long origin = Long.parseLong(st.nextToken());
        long target = Long.parseLong(st.nextToken());

        ArrayDeque<long[]> queue = new ArrayDeque<long[]>();
        queue.add(new long[]{ origin, 1 });

        while (queue.isEmpty() == false) {

            long[] current = queue.poll();
            long currentNum = current[0];
            long currentCount = current[1];

            if (currentNum == target) { 
                System.out.println(currentCount);
                return;
            }

            if (currentNum * 2 <= target) { queue.add(new long[]{ currentNum * 2, currentCount + 1}); }
            if (currentNum * 10 + 1 <= target) { queue.add(new long[]{ currentNum * 10 + 1, currentCount + 1}); }
        }

        System.out.print(-1);
    }

}

```

`bfs`로 풀었다. `origin`에서 시작해 `target`까지 진행하며 **모든 구간을 탐색**한다. 당연히 `v1 Greedy`에 비해 느릴 수 밖에 없다. `while`이 시작되기 전에 조기종료 구문을 넣어봤으나 속도에서 이득을 보지 못했다. 



## v3 (python)

```python
"""백준 16953"""

def get_count(num_a, num_b) :
    """get count"""

    count = 1
    while num_b > num_a :

        if num_b % 2 == 0 :
            num_b = num_b // 2
        elif num_b % 10 == 1 :
            num_b = num_b // 10
        else :
            return -1
        count = count + 1

    if num_b == num_a :
        return count
    return -1

if __name__ == "__main__" :
    origin, target = map(int, input().split())
    print(get_count(origin, target))

```

마찬가지로 `Greedy`로 푼 `python` 버전이다. 



## 정리

본 문제는 특정 탐색 알고리즘 보다 `Greedy`로 풀어내는 것이 적합하다.



## 결과

![image-20250725171026953](C:\00-dev-workspace\algorithms\01 solved.ac (baekjoon)\02. Silver\assets\image-20250725171026953.png)