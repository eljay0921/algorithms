# [1463. 1로 만들기](https://www.acmicpc.net/problem/1463)

> 실버 3

| 시간 제한                                                    | 메모리 제한 | 제출   | 정답   | 맞힌 사람 | 정답 비율 |
| ------------------------------------------------------------ | ----------- | ------ | ------ | --------- | --------- |
| 0.15 초 ([하단 참고](https://www.acmicpc.net/problem/1463#)) | 128 MB      | 362208 | 127121 | 81193     | 33.650%   |

## 문제

정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
2. X가 2로 나누어 떨어지면, 2로 나눈다.
3. 1을 뺀다.

정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

## 입력

첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.

## 출력

첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.

## 예제 입력 1 복사

```
2
```

## 예제 출력 1 복사

```
1
```

## 예제 입력 2 복사

```
10
```

## 예제 출력 2 복사

```
3
```

## 힌트

10의 경우에 10 → 9 → 3 → 1 로 3번 만에 만들 수 있다.

# Solutions

## v1 (Back Tracking)

```java
import java.io.*;

public class Main {

    private static int MIN_COUNT;
    
    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int number = Integer.parseInt(br.readLine());

        MIN_COUNT = Integer.MAX_VALUE;
        backTrack(number, 0);

        System.out.println(MIN_COUNT);
    }

    // 종료 조건 + 현재 동작
    // 전처리 + 재귀 호출
    private static void backTrack(int startNumber, int count) {

        // 이미 최소 카운트를 넘겼다면 skip
        if (count >= MIN_COUNT) {
            return; 
        }

        // 종료 조건
        if (startNumber == 1) {

            MIN_COUNT = Math.min(MIN_COUNT, count);
            return;
        }

        if (startNumber % 3 == 0) {
            backTrack(startNumber / 3, count + 1);
        }

        if (startNumber % 2 == 0) {
            backTrack(startNumber / 2, count + 1);
        }

        backTrack(startNumber - 1, count + 1);
    }
}
```

처음 주어진 숫자에 대해서 3으로 나누든, 2로 나누든, 1을 빼든 최종적으로 1에 도달하기까지 얼마나 걸릴 지 알 수 없으며, 또한 그 거리 중 최단 거리를 찾기 위해선 모든 케이스를 확인 해봐야 알 수 있다는 점에서 일단 `BackTracking` 기법을 적용해봤다. `가지치기` 로직을 넣어두어서 방어하긴 했지만 이 기법은 “시간을 초과하지 않을까?” 하는 걱정이 있었다. 하지만 결과는 `100ms`로 준수한 속도로 통과했다. 그럼에도 불구하고 이를 **더 빠르게 동작할 수 있는 방법**을 찾아봤다.

## v2 (DP)

```java
import java.io.*;

public class Main {
  
    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int number = Integer.parseInt(br.readLine());

        // DP
        int[] dp = new int[number + 1];
        dp[1] = 0;

        for (int i = 2; i <= number; i++) {
            dp[i] = dp[i - 1] + 1;

            if (i % 2 == 0) {
                dp[i] = Math.min(dp[i], dp[i / 2] + 1);
            }

            if (i % 3 == 0) {
                dp[i] = Math.min(dp[i], dp[i / 3] + 1);
            }
        }

        System.out.println(dp[number]);
    }
}
```

이번에는 DP를 적용했다. 대상 숫자(`number`)까지 도달하는 경우에 대한 값을 미리 계산하는 방식이다. 결과는 `96ms`로 근소한 차이로 더 빠르지만, **유의미한 차이는 아닌** 것 같다. 물론 코드는 더 간결해졌다. 현재의 문제는 원하는 스타일로 풀어도 무방할 것으로 보인다.

## 정리

`DP`의 점화식이 복잡한 문제라면 `BackTracking`이 유리할 것이나, 점화식이 간단하고 입력 값이 지금보다 더 크다면 `DP`가 유리할 것으로 보인다. 

