# [N과 M (9)](https://www.acmicpc.net/problem/15663)

> 실버 2

| 시간 제한 | 메모리 제한 | 제출  | 정답  | 맞힌 사람 | 정답 비율 |
| :-------- | :---------- | :---- | :---- | :-------- | :-------- |
| 1 초      | 512 MB      | 56125 | 28371 | 21657     | 49.531%   |

## 문제

N개의 자연수와 자연수 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.

- N개의 자연수 중에서 M개를 고른 수열

## 입력

첫째 줄에 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)

둘째 줄에 N개의 수가 주어진다. 입력으로 주어지는 수는 10,000보다 작거나 같은 자연수이다.

## 출력

한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.

수열은 사전 순으로 증가하는 순서로 출력해야 한다.

## 예제 입력 1 복사

```
3 1
4 4 2
```

## 예제 출력 1 복사

```
2
4
```

## 예제 입력 2 복사

```
4 2
9 7 9 1
```

## 예제 출력 2 복사

```
1 7
1 9
7 1
7 9
9 1
9 7
9 9
```

## 예제 입력 3 복사

```
4 4
1 1 1 1
```

## 예제 출력 3 복사

```
1 1 1 1
```

---

# Solutions

## v1 (잘못된 버전 ❌)

```java
import java.io.*;
import java.util.*;

public class Main {

    private static int SIZE;
    private static int[] NUMS;
    private static StringBuilder SB;
    
    public static void main(String[] args) throws IOException {

        // 1. 입력 및 전처리
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int count = Integer.parseInt(st.nextToken());
        SIZE = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());

        NUMS = new int[count];
        for (int i = 0; i < count; i++) {
            NUMS[i] = Integer.parseInt(st.nextToken());
        }
        
        // 2. 정렬
        Arrays.sort(NUMS);       

        // 3. processing
        boolean[] visited = new boolean[10001]; // 숫자는 최대 10000 보다 작거나 같다고 했다.
        int[] prints = new int[SIZE];
        SB = new StringBuilder();
        backTrack(0, prints, visited);

        System.out.print(SB);
    }

    private static void backTrack(int depth, int[] prints, boolean[] visited) {

        // 종료 조건 + 현재 동작
        // 전처리 + 다음 동작(재귀)

        if (depth == SIZE) {

            for (int i = 0; i < prints.length; i++) {
                SB.append(prints[i]).append(" ");
            }
            SB.append("\n");

            return;
        }

        int prev = -1;
        for (int i = 0; i < NUMS.length; i++) {

            int current = NUMS[i];
            if (visited[current] == false && current != prev) {

                visited[current] = true;
                prints[depth] = current;
                
                backTrack(depth + 1, prints, visited);
                
                visited[current] = false;
                prev = current;
            }
        }
    }
}

// 2 4 4 
// 1 7 9 9 
// 1 1 1 1
```

위 코드는 **잘못 만든 버전**이다. 마치 그럴싸하게 풀리지만, 입력  예제 `2`와 `3`번 모두 실패할 것이다. 위 코드는 현재 `depth`에서 중복된 숫자를 인지하지 못하고, 무조건 중복된 숫자는 넘어가게 되어있다. `depth`를 기준으로 `visited`를 체크할 필요가 있다. 문제의 출력 예제를 보면 숫자가 중복되더라도, **수열 자체가 중복되지 않으면 유효**하다. 



## v2 (개선)

```java
import java.io.*;
import java.util.*;

public class Main {

    private static int SIZE;
    private static int[] NUMS;
    private static StringBuilder SB;
    
    public static void main(String[] args) throws IOException {

        // 1. 입력 및 전처리
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int count = Integer.parseInt(st.nextToken());
        SIZE = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());

        NUMS = new int[count];
        for (int i = 0; i < count; i++) {
            NUMS[i] = Integer.parseInt(st.nextToken());
        }
        
        // 2. 정렬
        Arrays.sort(NUMS);       

        // 3. processing
        boolean[] visited = new boolean[NUMS.length];   // "숫자" 별 체크가 아니라, "인덱스(depth)" 별 체크로 변경
        int[] prints = new int[SIZE];
        SB = new StringBuilder();
        backTrack(0, prints, visited);

        System.out.print(SB);
    }

    private static void backTrack(int depth, int[] prints, boolean[] visited) {

        // 종료 조건 + 현재 동작
        // 전처리 + 다음 동작(재귀)

        if (depth == SIZE) {

            for (int i = 0; i < prints.length; i++) {
                SB.append(prints[i]).append(" ");
            }
            SB.append("\n");

            return;
        }

        int prev = -1;
        for (int i = 0; i < NUMS.length; i++) {

            if (visited[i] == false && NUMS[i] != prev) {

                visited[i] = true;
                prints[depth] = NUMS[i];
                
                backTrack(depth + 1, prints, visited);
                
                visited[i] = false;
                prev = NUMS[i];
            }
        }
    }
}


// 2 4 4 
// 1 7 9 9 
// 1 1 1 1
```

### 변경된 사항

1. `boolean[] visited` 선언부 : 길이는 `10001`이 아니라, `NUMS.length`를 받고 있다.
2. `backTrack` 로직 내, `visited` 확인 부분 : 현재 **숫자**(current / NUMS[i])가 아니라, 현재 **위치**(i / depth)를 보도록 변경했다.

알고리즘 테스트 결과는 `96ms`로 꽤 빠른 속도를 보였다.

### Java 기준 다른 사람들의 결과와 비교

![image-20250721182452378](C:\00-dev-workspace\algorithms\01 solved.ac (baekjoon)\02. Silver\assets\image-20250721182452378.png)