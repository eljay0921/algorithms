# [피보나치 함수](https://www.acmicpc.net/problem/1003)

**실버 3**

| 시간 제한                | 메모리 제한 | 제출   | 정답  | 맞힌 사람 | 정답 비율 |
| ------------------------ | ----------- | ------ | ----- | --------- | --------- |
| 0.25 초 (추가 시간 없음) | 128 MB      | 252220 | 81724 | 64796     | 34.351%   |

## 문제

다음 소스는 N번째 피보나치 수를 구하는 C++ 함수이다.

```
int fibonacci(int n) {
    if (n == 0) {
        printf("0");
        return 0;
    } else if (n == 1) {
        printf("1");
        return 1;
    } else {
        return fibonacci(n‐1) + fibonacci(n‐2);
    }
}
```

`fibonacci(3)`을 호출하면 다음과 같은 일이 일어난다.

- `fibonacci(3)`은 `fibonacci(2)`와 `fibonacci(1)` (첫 번째 호출)을 호출한다.
- `fibonacci(2)`는 `fibonacci(1)` (두 번째 호출)과 `fibonacci(0)`을 호출한다.
- 두 번째 호출한 `fibonacci(1)`은 1을 출력하고 1을 리턴한다.
- `fibonacci(0)`은 0을 출력하고, 0을 리턴한다.
- `fibonacci(2)`는 `fibonacci(1)`과 `fibonacci(0)`의 결과를 얻고, 1을 리턴한다.
- 첫 번째 호출한 `fibonacci(1)`은 1을 출력하고, 1을 리턴한다.
- `fibonacci(3)`은 `fibonacci(2)`와 `fibonacci(1)`의 결과를 얻고, 2를 리턴한다.

1은 2번 출력되고, 0은 1번 출력된다. N이 주어졌을 때, `fibonacci(N)`을 호출했을 때, 0과 1이 각각 몇 번 출력되는지 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 테스트 케이스의 개수 T가 주어진다.

각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다. N은 40보다 작거나 같은 자연수 또는 0이다.

## 출력

각 테스트 케이스마다 0이 출력되는 횟수와 1이 출력되는 횟수를 공백으로 구분해서 출력한다.



## 예제 입력 1 						

```
3
0
1
3
```

## 예제 출력 1 						

```
1 0
0 1
1 2
```

## 예제 입력 2 						

```
2
6
22
```

## 예제 출력 2 						

```
5 8
10946 17711
```

---

# Solutions

## v1

```java
import java.io.*;

public class Main {
    
    private static int CNT_0 = 0, CNT_1 = 0;
    
    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int count = Integer.parseInt(br.readLine());

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < count; i++) {

            CNT_0 = 0;
            CNT_1 = 0;

            int num = Integer.parseInt(br.readLine());
            fibonacci(num);
            sb.append(CNT_0 + " ").append(CNT_1 + "\n");
        }
        
        System.out.print(sb);
        br.close();
    }
    
    private static int fibonacci(int n) {
        if (n == 0) {
            CNT_0++;
            return 0;
        } else if (n == 1) {
            CNT_1++;
            return 1;
        } else {
            return fibonacci(n - 1) + fibonacci(n - 2);
        }
    }
}
```

먼저, 주어진 공식을 그대로 적용해 풀어봤지만 역시 우려했던 대로 시간 초과에 의해 실패했다. 문제의 시간 제한이 짧은 것은, 그만큼 **효율적인 알고리즘**을 적용하라는 의도로 보인다.

## v2 (dp)

```java
import java.io.*;

public class Main {
    
    public static void main(String[] args) throws IOException {

        // dp 초기화 및 전처리
        int[][] dp = new int[41][2];
        dp[0][0] = 1;
        dp[0][1] = 0;
        dp[1][0] = 0;
        dp[1][1] = 1;

        for (int i = 2; i < 41; i++) {
            dp[i][0] = dp[i - 1][0] + dp[i - 2][0];
            dp[i][1] = dp[i - 1][1] + dp[i - 2][1];
        }

        // 입력 값 기준 dp에서 꺼내기
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int count = Integer.parseInt(br.readLine());

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < count; i++) {
            int num = Integer.parseInt(br.readLine());
            sb.append(dp[num][0]).append(" ").append(dp[num][1]).append("\n");
        }

        System.out.print(sb);
        br.close();
    }
}
```

`68ms`의 결과를 보였다. 역시 속도(성능) 면에서 효율을 고려할 때는 `dp`가 자주 필요한 것 같다(~~아직까지 silver 수준에선 그렇다~~). 미리 `fibonacci` 0부터 40까지 계산을 해놓고 활용하는 방식이다. `N`이 최대 `40`까지인 조건에 따른 것이며, 천에서 만 단위까지 올라가더라도 충분한 성능을 보일 것 같다. 

하지만 `gemini`에게 물어보니, 숫자 `N`이 `10만` 정도가 되면 **100초 이상 소요**될 것으로 계산하고 있다. 이 경우, `gemini`의 답변에 따르면 `dp`로도 충분치 않고, **행렬 곱셈**을 적용해야 한다. 

역시 학생 때 배웠던 것은 다 쓸모가 있구나 싶다... 하지만, 이건 다음에 알아보자.