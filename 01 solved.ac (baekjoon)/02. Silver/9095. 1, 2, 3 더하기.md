# [1, 2, 3 더하기](https://www.acmicpc.net/problem/9095)

> 실버 3

| 시간 제한             | 메모리 제한 | 제출   | 정답  | 맞힌 사람 | 정답 비율 |
| --------------------- | ----------- | ------ | ----- | --------- | --------- |
| 1 초 (추가 시간 없음) | 512 MB      | 146076 | 96941 | 67685     | 64.984%   |

## 문제

정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 7가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다.

- 1+1+1+1
- 1+1+2
- 1+2+1
- 2+1+1
- 2+2
- 1+3
- 3+1

정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 11보다 작다.

## 출력

각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 출력한다.

​			 		

## 예제 입력 1 						

```
3
4
7
10
```

## 예제 출력 1 						

```
7
44
274
```

---

# Solutions

## v1 (back tracking)

```java
import java.io.*;

public class q9095 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        br.readLine();

        StringBuilder sb = new StringBuilder();
        while(br.ready()) {
            int num = Integer.parseInt(br.readLine());
            int total = backTrack(num, 0);
            sb.append(total).append("\n");
        }

        System.out.print(sb);
    }

    private static int backTrack(int target, int current) {

        // 종료 조건 + 현재 동작
        // 전처리 + 다음 동작(재귀)

        if (current == target) return 1;
        if (current > target) return 0;

        int count = 0;
        for (int i = 1; i <= 3; i++) {  // 1, 2, 3
            count += backTrack(target, current + i);
        }

        return count;
    }
}

```

처음에 든 생각은 `dp` 또는 `back tracking`으로 가능하겠단 생각이 들었다. ~~절대 점화식을 생각하기 귀찮아서 `back tracking`으로 짠 것은 아니다.~~ 속도가 좀 느리지 않을까 걱정했는데 `64ms`로 생각보다 빠른 성능을 보였다. 다행히 입력 숫자 `n`이 **양의 정수로 10까지**다. 

## v2 (DP)

```java
import java.io.*;

public class q9095_dp {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        br.readLine();

        int[] dp = new int[11]; // 1 <= n <= 10
        dp[1] = 1;
        dp[2] = 2;
        dp[3] = 4;
        // dp[4] = 7;

        StringBuilder sb = new StringBuilder();
        while (br.ready()) {
            int num = Integer.parseInt(br.readLine());
            for (int i = 4; i <= num; i++) {
                if (dp[i] == 0) {
                    dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
                }
            }

            sb.append(dp[num]).append("\n");
        }

        System.out.print(sb);
    }
}

// 4 -> (7)
// 1 1 1 1
// 1 1 2
// 1 2 1
// 2 1 1
// 2 2
// 1 3
// 3 1

// 3 -> (4)
/*
 * 1 1 1
 * 1 2
 * 2 1
 * 3
 */

 // 2 -> (2)
 /*
  * 1 1
  * 2
  */

// 1 -> (1)
/*
 * 1
 */
```

이번엔 `dp`를 이용한 풀이다. 근데 똑같이 64ms로 같은 결과가 나왔다. 입력 값이 이처럼 크지 않다면 `back tracking`으로도 충분하겠다.

근데 역시 난 점화식을 세우는 데 약하단 것을 다시 한 번 느꼈다. 솔직히 말하자면, 패턴을 보니까 4를 만드는 경우의 수가 1과 2, 3을 만드는 경우의 수를 합하니 동일하다는 기준만 가지고 점화식을 세웠다. ~~엉망진창~~ 제대로 이해하지 못하고 짠 코드인 셈이다. 결국 `chatGPT`를 통해 이해할 수 있었지만 비슷한 문제가 다르게 꼬여서 나온다면 또 헷갈릴 것 같다. 아래는 gpt의 설명이다.

---

### 점화식 도출

어떤 수 `j`를 만들기 위해서는 **마지막에 더한 숫자**가 무엇인지에 따라 경우를 나눌 수 있습니다.

#### 1) 마지막에 `1`을 더한 경우

- 마지막에 `1`을 더했다면, 그 전까지는 `j-1`을 만들었어야 합니다.
- 경우의 수: `dp[j-1]`

#### 2) 마지막에 `2`를 더한 경우

- 마지막에 `2`를 더했다면, 그 전까지는 `j-2`를 만들었어야 합니다.
- 경우의 수: `dp[j-2]`

#### 3) 마지막에 `3`을 더한 경우

- 마지막에 `3`을 더했다면, 그 전까지는 `j-3`을 만들었어야 합니다.
- 경우의 수: `dp[j-3]`

위 3가지 경우는 **서로 겹치지 않고, 전체 경우의 수는 이들의 합**입니다.
$$
dp[j] = dp[j-1] + dp[j-2] + dp[j-3]
$$

---

### (추가)

만약 연산에 사용할 수 있는 숫자가 1,2,3,4였다면 점화식은 다음과 같을 것이다.
$$
dp[j] = dp[j-1] + dp[j-2] + dp[j-3] + dp[j-4]
$$

---

## v3 (python - back tracking)

```python
"""백준 9095. 1, 2, 3 더하기"""

def backTrack(target, current) :
    """back tracking for target"""
    if current == target : return 1
    if current > target : return 0

    temp_count = 0
    for i in range(1, 4) :
        temp_count += backTrack(target, current + i)

    return temp_count


numbers = int(input())

for _ in range(numbers) :
    num = int(input())
    total = backTrack(num, 0)
    print(total)

```

## v3 (python - dp)

```python
"""백준 9095. 1, 2, 3 더하기"""

dp = [0] * 11   # 1 <= n <= 10
dp[1] = 1
dp[2] = 2
dp[3] = 4

numbers = int(input())
for _ in range(0, numbers) :

    target = int(input())
    for i in range(4, target + 1) :
        if (dp[i] == 0) :
            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]
    
    print(dp[target])

```



---

| 제출 번호 | 결과         | 메모리 | 시간 | 언어                                                         | 코드 길이 |
| --------- | ------------ | ------ | ---- | ------------------------------------------------------------ | --------- |
| 96865307  | 맞았습니다!! | 32412  | 36   | [Python 3](https://www.acmicpc.net/source/96865307) / [수정](https://www.acmicpc.net/submit/9095/96865307) | 322       |
| 96865038  | 맞았습니다!! | 32412  | 36   | [Python 3](https://www.acmicpc.net/source/96865038) / [수정](https://www.acmicpc.net/submit/9095/96865038) | 422       |
| 96864411  | 맞았습니다!! | 11464  | 64   | [Java 8](https://www.acmicpc.net/source/96864411) / [수정](https://www.acmicpc.net/submit/9095/96864411) | 919       |
| 96863653  | 맞았습니다!! | 11468  | 64   | [Java 8](https://www.acmicpc.net/source/96863653) / [수정](https://www.acmicpc.net/submit/9095/96863653) | 872       |