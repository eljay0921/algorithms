# [트리의 부모 찾기](https://www.acmicpc.net/problem/11725)

**실버 2**

| 시간 제한 | 메모리 제한 | 제출   | 정답  | 맞힌 사람 | 정답 비율 |
| --------- | ----------- | ------ | ----- | --------- | --------- |
| 1 초      | 256 MB      | 108731 | 50199 | 35120     | 43.728%   |

## 문제

루트 없는 트리가 주어진다. 이때, 트리의 루트를 1이라고 정했을 때, 각 노드의 부모를 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 노드의 개수 N (2 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N-1개의 줄에 트리 상에서 연결된 두 정점이 주어진다.

## 출력

첫째 줄부터 N-1개의 줄에 각 노드의 부모 노드 번호를 2번 노드부터 순서대로 출력한다.

​			 		

## 예제 입력 1 						

```
7
1 6
6 3
3 5
4 1
2 4
4 7
```

## 예제 출력 1 						

```
4
6
1
3
1
4
```

## 예제 입력 2 						

```
12
1 2
1 3
2 4
3 5
3 6
4 7
4 8
5 9
5 10
6 11
6 12
```

## 예제 출력 2 						

```
1
1
2
3
3
4
4
5
5
6
6
```

---

# Solutions

처음에는 ~~뭔 소리인지~~ 이해가 잘 안 되었다. `트리`를 글로 표현하고 입력 값을 써 놓으니 눈에 들어오지 않았던 것이다. 예제 입력 2가지를 **그림으로 그려**보니 이해가 되기 시작했다. 문제에서 `루트`는 항상 `1`이라는 가정이 있다. 그리고 트리에서 **자식**은 `n`개가 가능하지만 **부모**는 `1`개라는 점을 기억하자.

```
	1
   /  \
  6     4
 /     /  \
3     2    7
|
5
```

```
           1
         /    \
       2        3
     /        /   \
   4         5      6
 /  \      /  \    /  \
7    8    9   10  11   12
```

그리고 나니 문제를 이해하기 쉬워졌다. 사실 내가 이해가 잘 되지 않았던 것은 출력 부분이었다. 배열 이름을 `parent`라고 한다면, 첫 번째 예제에서 `parent[2] = 4`, `parent[5] = 3`이라는 것이다. 이제야 문제가 이해되었다. (~~머리가 굳었다~~)

하지만 알고리즘을 짜는 것도 쉬울 지는 별개의 이야기지.

## v1 (BFS)

```java
import java.io.*;
import java.util.*;

public class Main {

    private static ArrayList<Integer>[] TREE;
    private static int[] PARENTS;
    private static boolean[] VISITED;

    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int count = Integer.parseInt(br.readLine());
        TREE = new ArrayList[count + 1];
        PARENTS = new int[count + 1];
        VISITED = new boolean[count + 1];

        // (1) 입력값 -> TREE로
        for (int i = 1; i <= count; i++) {
            TREE[i] = new ArrayList<>();
        }
        for (int i = 0; i < count - 1; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int num1 = Integer.parseInt(st.nextToken());
            int num2 = Integer.parseInt(st.nextToken());

            // 간선 정보 구축
            TREE[num1].add(num2);
            TREE[num2].add(num1);
        }

        // (2) bfs: PARENTS 찾기        
        bfs(1);

        // (3) 출력
        StringBuilder sb = new StringBuilder();
        for (int i = 2; i <= count; i++) {
            sb.append(PARENTS[i]).append("\n");
        }
        System.out.print(sb);
        br.close();
    }

    private static void bfs(int num) {
        ArrayDeque<Integer> queue = new ArrayDeque<>();
        queue.add(num);
        VISITED[num] = true;

        while (queue.isEmpty() == false) {
            int current = queue.poll();
            for (int node : TREE[current]) {
                if (VISITED[node] == false) {
                    VISITED[node] = true;
                    PARENTS[node] = current;
                    queue.add(node);
                }
            }
        }
    }
}
```

결국 몇 차례 헤메다가 `AI`의 도움을 받았다. 아직 탐색 알고리즘 문제를 풀어본 적이 없어서 그렇다는 변명을 해본다. 기본적으로 방문 처리를 위한 `VISITED` 배열과 **너비 우선 탐색(BFS)** 답게 순서대로 처리하기 위함으로 `Queue`를 사용한다. 본문에서는 `ArrayDeque`를 활용했다. 크게 이 2가지를 잘 생각하면 풀기 어렵지 않을 것으로 생각한다. 

## v2 (DFS)

```java
import java.io.*;
import java.util.*;

public class Main {

    private static ArrayList<Integer>[] TREE;
    private static int[] PARENTS;
    private static boolean[] VISITED;

    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int count = Integer.parseInt(br.readLine());
        TREE = new ArrayList[count + 1];
        PARENTS = new int[count + 1];
        VISITED = new boolean[count + 1];

        // (1) 입력값 -> TREE로
        for (int i = 1; i <= count; i++) {
            TREE[i] = new ArrayList<>();
        }
        for (int i = 0; i < count - 1; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int num1 = Integer.parseInt(st.nextToken());
            int num2 = Integer.parseInt(st.nextToken());

            // 간선 정보 구축
            TREE[num1].add(num2);
            TREE[num2].add(num1);
        }

        // (2) bfs/dfs: PARENTS 찾기        
        dfs(1, 0);

        // (3) 출력
        StringBuilder sb = new StringBuilder();
        for (int i = 2; i <= count; i++) {
            sb.append(PARENTS[i]).append("\n");
        }
        System.out.print(sb);
        br.close();
    }

    private static void dfs(int num, int parent) {

        VISITED[num] = true;
        PARENTS[num] = parent;

        for (int node : TREE[num]) {
            if (VISITED[node] == false) {
                dfs(node, num);
            }
        }
    }
}
```

어...? 완전히 처음은 아니었다. 생각해보니, 이전까지 `BackTracking` 기법으로 풀어온 문제들이 있었는데 그게 `DFS`와 '유사'하다. `DFS`는 **깊이 우선 탐색**으로, 지금까지 풀었던 백준의 `N과 M` 문제들이 `BackTracking`으로 해결할 수 있는 예이다. 다만, `DFS`는 모든 노드를 방문해서 확인할 때 필요하고, `Backtracking`은 중간에 빠져나올 수 있는 형태로 구현하므로 분명 차이점은 존재한다. 공통적으로 두 가지 방식 모두 어떤 결과에 도달하기 위해 **재귀 호출**을 이용한다는 것이다.

그래도 헷갈리지 않게 비교를 통해 정리하자.

| 특징             | DFS (깊이 우선 탐색)                       | 백트래킹 (Backtracking)                                      |
| ---------------- | ------------------------------------------ | ------------------------------------------------------------ |
| 목적             | 그래프/트리 탐색 및 도달 가능성 확인       | 문제의 해를 찾고, 제약 조건 만족 여부 확인                   |
| 적용 범위        | 그래프 이론의 알고리즘                     | 일반적인 문제 해결 기법 (주로 조합 탐색)                     |
| "Backtrack" 의미 | 탐색할 경로가 없을 때 이전 노드로 되돌아감 | 잘못된 선택을 취소하고 다른 선택을 시도함                    |
| 상태 관리        | visited 배열/Set로 방문 여부만 관리        | 현재까지의 부분 해(partial solution) 상태를 유지하고, 선택을 undo할 필요가 있음 |
| 사용 예시        | 연결 요소 찾기, 사이클 감지, 위상 정렬     | N-Queens, 스도쿠 해결, 순열/조합 생성, 부분집합 합           |

아무튼, `DFS`로 푼 것이 훨씬 더 간결하고 덕분에 가독성도 좋다. `BFS`에서 `Queue`를 사용했다면, 보통 `DFS`에서는 `Stack`을 사용하는데, 이번 문제에서는 불필요했다. 성능에서도 `v1(BFS)`의 경우 `632ms`, `v2(DFS)`의 경우 `552ms`로 `DFS`가 조금 더 빨랐다.

## [BFS vs DFS 보기](..\..\00 commons\BFS vs DFS 비교표.md)

