# 최대공약수와 최소공배수

| 시간 제한 | 메모리 제한 | 제출   | 정답  | 맞힌 사람 | 정답 비율 |
| :-------- | :---------- | :----- | :---- | :-------- | :-------- |
| 1 초      | 128 MB      | 137381 | 79535 | 64848     | 57.716%   |

## 문제

두 개의 자연수를 입력받아 최대 공약수와 최소 공배수를 출력하는 프로그램을 작성하시오.

## 입력

첫째 줄에는 두 개의 자연수가 주어진다. 이 둘은 10,000이하의 자연수이며 사이에 한 칸의 공백이 주어진다.

## 출력

첫째 줄에는 입력으로 주어진 두 수의 최대공약수를, 둘째 줄에는 입력으로 주어진 두 수의 최소 공배수를 출력한다.

## 예제 입력 1 

```
24 18
```

## 예제 출력 1 

```
6
72
```



---

# Solutions

## v1 (무작정 찾기)

```java
import java.util.*;
import java.io.*;

public class Q2609 {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int num1 = Integer.parseInt(st.nextToken());
        int num2 = Integer.parseInt(st.nextToken());

        int gcd = getGCD(num1, num2);
        int lcm = getLCM(num1, num2);

        StringBuilder sb = new StringBuilder();
        sb.append(gcd).append(" ").append(lcm);
        System.out.print(sb);
        
        br.close();
    }

    // 최대공약수(Greatest Common Divisor) 찾기
    private static int getGCD(int num1, int num2) {
        // 무작정 찾기
        int smaller = Math.min(num1, num2); 
        while (smaller > 0) {

            if (num1 % smaller == 0 && num2 % smaller == 0) {
                break;
            }
            smaller--;
        }

        return smaller;
    }

    private static int getLCM(int num1, int num2) {
        // 무작정 찾기
        int bigger = Math.max(num1, num2);
        while (true) {

            if (bigger % num1 == 0 && bigger % num2 == 0) {
                break;
            }
            bigger++;
        }

        return bigger;
    }
}
```

`최대공약수`와 `최소공배수`를 찾는 공식이 분명 있을 것이나… 학생 때 배운 수학은 잊어버린 지 오래다. 일단 **무작정 찾는 방법**으로 풀어봤다. 당연하게도 정답은 맞췄으나, 다른 사람들의 결과에 비해 **느리다**. 다들 공식을 찾아서 푼 것으로 추정된다.

## v2 (공식 적용)

```java
import java.util.*;
import java.io.*;

public class Q2609 {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int num1 = Integer.parseInt(st.nextToken());
        int num2 = Integer.parseInt(st.nextToken());

        int gcd = getGCD(num1, num2);
        int lcm = getLCM(num1, num2);

        StringBuilder sb = new StringBuilder();
        sb.append(gcd).append(" ").append(lcm);
        System.out.print(sb);

        br.close();
    }

    // 최대공약수(Greatest Common Divisor) 찾기
    private static int getGCD(int num1, int num2) {
        // 유클리드 호제법
        while (num2 != 0) {
            int temp = num2;
            num2 = num1 % num2;
            num1 = temp;
        }
        return num1;
    }

    // 최소공배수(Least Common Multiple) 찾기
    private static int getLCM(int num1, int num2) {
        return (num1 * num2) / getGCD(num1, num2);
    }
}
```

이번엔 `유클리드 호제법`을 적용했다. **최대공약수**를 찾는 방법이고, 이를 이용해 **최소공배수**까지 깔끔하게 찾는다. 역시 어릴 때 학교에서 배운 것은 언젠가 다 쓸모가 있구나… ~~배웠던 거 맞겠지?~~ 

## 정리

무작정 찾기 `v1`은 `264ms`가 걸린 매우 느린 코드다. 공식을 잊어버렸다면 이렇게라도 풀어야겠으나, 가능하다면 `유클리드 호제법`을 기억해서 활용하자. `v2`는 `60ms` 밖에 걸리지 않았다. 
