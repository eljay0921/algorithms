# [평균](https://www.acmicpc.net/problem/1546)

브론즈 1

| 시간 제한 | 메모리 제한 | 제출   | 정답   | 맞힌 사람 | 정답 비율 |
| --------- | ----------- | ------ | ------ | --------- | --------- |
| 2 초      | 128 MB      | 337779 | 172369 | 138766    | 50.450%   |

## 문제

세준이는 기말고사를 망쳤다. 세준이는 점수를 조작해서 집에 가져가기로 했다. 일단 세준이는 자기 점수 중에 최댓값을 골랐다. 이 값을 M이라고 한다. 그리고 나서 모든 점수를 점수/M*100으로 고쳤다.

예를 들어, 세준이의 최고점이 70이고, 수학점수가 50이었으면 수학점수는 50/70*100이 되어 71.43점이 된다.

세준이의 성적을 위의 방법대로 새로 계산했을 때, 새로운 평균을 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 시험 본 과목의 개수 N이 주어진다. 이 값은 1000보다 작거나 같다. 둘째 줄에 세준이의 현재 성적이 주어진다. 이 값은 100보다 작거나 같은 음이 아닌 정수이고, 적어도 하나의 값은 0보다 크다.

## 출력

첫째 줄에 새로운 평균을 출력한다. 실제 정답과 출력값의 절대오차 또는 상대오차가 10-2 이하이면 정답이다.

​			 		

## 예제 입력 1 						

```
3
40 80 60
```

## 예제 출력 1 						

```
75.0
```

## 예제 입력 2 						

```
3
10 20 30
```

## 예제 출력 2 						

```
66.666667
```

10-2 이하의 오차를 허용한다는 말은 정확히 소수 2번째 자리까지 출력하라는 뜻이 아니다.

## 예제 입력 3 						

```
4
1 100 100 100
```

## 예제 출력 3 						

```
75.25
```

## 예제 입력 4 						

```
5
1 2 4 8 16
```

## 예제 출력 4 						

```
38.75
```

## 예제 입력 5 						

```
2
3 10
```

## 예제 출력 5 						

```
65.0
```

## 예제 입력 6 						

```
4
10 20 0 100
```

## 예제 출력 6 						

```
32.5
```

## 예제 입력 7 						

```
1
50
```

## 예제 출력 7 						

```
100.0
```

## 예제 입력 8 						

```
9
10 20 30 40 50 60 70 80 90
```

## 예제 출력 8 						

```
55.55555555555556
```

---

# Solutions

## v1 (최적화)

```java
import java.io.*;
import java.util.StringTokenizer;

public class Main {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int count = Integer.parseInt(br.readLine());

        StringTokenizer st = new StringTokenizer(br.readLine());
        int[] scores = new int[count];
        int maxScore = 0;
        for (int i = 0; i < count; i++) {
            scores[i] = Integer.parseInt(st.nextToken());
            maxScore = Math.max(maxScore, scores[i]);
        }

        double totalScore = 0 ;
        for (int i = 0; i < count; i++) {
            totalScore = totalScore + ((double) scores[i] / maxScore * 100);
        }

        System.out.print(totalScore / count);
    }
    
}

```

## v2 (Stream)

```java
import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int count = Integer.parseInt(br.readLine());    // 미사용

        double[] scores = Arrays.stream(br.readLine().split(" ")).mapToDouble(Double::parseDouble).toArray();
        double maxScore = Arrays.stream(scores).max().getAsDouble();
        double average = Arrays.stream(scores).map(score -> score / maxScore * 100).average().getAsDouble();

        System.out.print(average);
    }
    
}

```

`v1`은 `Stream` API 없이 정직하게(?) 짠 로직이고, `v2`는 `Stream`을 사용했다. `v1`는 `68ms`라는 빠른 속도를 보였지만 로직이 길고, `v2`는 코드가 짧고 가독성이 좋지만 `220ms`라는 매우 느린 속도를 보였다.

### 잡생각

solved.ac(백준)에서 문제를 풀다 보면, `java`로 아무리 열심히 짜도 **60~100ms** 사이에서 결과가 나온다. 내가 못하는 거겠지만, 훨씬 간단해 보이는 `Python 3`의 로직을 볼 때면 현타가 온다. 정말 쉽게 쉽게 작성한 코드로 보이는데 **40~50ms**가 나오고 있으니 말이다. 물론 성능에선 `C++`이 최고존엄이고, 간혹 보이는 `C#` 결과도 대부분 빠른 편이다. 간혹 보이는 node.js도 준수한 가독성에 준수한 속도를 자랑한다. 같은 문제에서 **90~100ms**로 확인된다. 이 속도는 `java`로 `stream` 없이 작성해야 나올 수 있는 수준과 비슷하다. 그러나 `Python`와 `node.js`의 로직은 훨씬 간결하다.

코드를 짧게 작성할 수 있고 가독성이 좋다는 것은 곧, 개발자의 생산성 향상으로 연결된다. 왜 Backend 시장에서 `Python`과 `node.js`가 잘 살아남아 있는지 알 수 있는 부분이다. 특히 요즘은 `Typescript`를 사용하는 `NestJS`를 사용하는 경우가 종종 보인다. 몇 년 전에만 해도 이걸 개인적으로 공부했었고, 시장에서 흔히 보이는 정도는 아니었다. 하지만 요즘 채용 공고를 보면 `NestJS`와 `FastAPI`가 은근히 많이 보인다. ~~기왕 공부한 김에 더 열심히 파볼 걸 그랬나~~

난 아직 `.Net Framework`와 `Spring Framework` 밖에 경험이 없다. 과거 개인적으로 공부했던 `NestJS`는 Hello World 수준이다. 앞으로 언어와 프레임워크에 휘둘리지(?) 않기 위해선 `Java` 외에 언어 학습에도 신경을 써야 하겠다.





