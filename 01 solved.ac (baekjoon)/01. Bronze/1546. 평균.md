# [평균](https://www.acmicpc.net/problem/1546)

브론즈 1

| 시간 제한 | 메모리 제한 | 제출   | 정답   | 맞힌 사람 | 정답 비율 |
| --------- | ----------- | ------ | ------ | --------- | --------- |
| 2 초      | 128 MB      | 337779 | 172369 | 138766    | 50.450%   |

## 문제

세준이는 기말고사를 망쳤다. 세준이는 점수를 조작해서 집에 가져가기로 했다. 일단 세준이는 자기 점수 중에 최댓값을 골랐다. 이 값을 M이라고 한다. 그리고 나서 모든 점수를 점수/M*100으로 고쳤다.

예를 들어, 세준이의 최고점이 70이고, 수학점수가 50이었으면 수학점수는 50/70*100이 되어 71.43점이 된다.

세준이의 성적을 위의 방법대로 새로 계산했을 때, 새로운 평균을 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 시험 본 과목의 개수 N이 주어진다. 이 값은 1000보다 작거나 같다. 둘째 줄에 세준이의 현재 성적이 주어진다. 이 값은 100보다 작거나 같은 음이 아닌 정수이고, 적어도 하나의 값은 0보다 크다.

## 출력

첫째 줄에 새로운 평균을 출력한다. 실제 정답과 출력값의 절대오차 또는 상대오차가 10-2 이하이면 정답이다.

​			 		

## 예제 입력 1 						

```
3
40 80 60
```

## 예제 출력 1 						

```
75.0
```

## 예제 입력 2 						

```
3
10 20 30
```

## 예제 출력 2 						

```
66.666667
```

10-2 이하의 오차를 허용한다는 말은 정확히 소수 2번째 자리까지 출력하라는 뜻이 아니다.

## 예제 입력 3 						

```
4
1 100 100 100
```

## 예제 출력 3 						

```
75.25
```

## 예제 입력 4 						

```
5
1 2 4 8 16
```

## 예제 출력 4 						

```
38.75
```

## 예제 입력 5 						

```
2
3 10
```

## 예제 출력 5 						

```
65.0
```

## 예제 입력 6 						

```
4
10 20 0 100
```

## 예제 출력 6 						

```
32.5
```

## 예제 입력 7 						

```
1
50
```

## 예제 출력 7 						

```
100.0
```

## 예제 입력 8 						

```
9
10 20 30 40 50 60 70 80 90
```

## 예제 출력 8 						

```
55.55555555555556
```

---

# Solutions

## v1 (최적화)

```java
import java.io.*;
import java.util.StringTokenizer;

public class Main {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int count = Integer.parseInt(br.readLine());

        StringTokenizer st = new StringTokenizer(br.readLine());
        int[] scores = new int[count];
        int maxScore = 0;
        for (int i = 0; i < count; i++) {
            scores[i] = Integer.parseInt(st.nextToken());
            maxScore = Math.max(maxScore, scores[i]);
        }

        double totalScore = 0 ;
        for (int i = 0; i < count; i++) {
            totalScore = totalScore + ((double) scores[i] / maxScore * 100);
        }

        System.out.print(totalScore / count);
    }
    
}

```

## v2 (Stream)

```java
import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int count = Integer.parseInt(br.readLine());    // 미사용

        double[] scores = Arrays.stream(br.readLine().split(" ")).mapToDouble(Double::parseDouble).toArray();
        double maxScore = Arrays.stream(scores).max().getAsDouble();
        double average = Arrays.stream(scores).map(score -> score / maxScore * 100).average().getAsDouble();

        System.out.print(average);
    }
    
}

```

`v1`은 `Stream` API 없이 정직하게(?) 짠 로직이고, `v2`는 `Stream`을 사용했다. `v1`는 `68ms`라는 빠른 속도를 보였지만 로직이 길고, `v2`는 코드가 짧고 가독성이 좋지만 `220ms`라는 매우 느린 속도를 보였다.

### 잡생각

solved.ac(백준)에서 문제를 풀다 보면, `java`로 아무리 열심히 짜도 **60~100ms** 사이에서 결과가 나온다. 내가 못하는 거겠지만, 훨씬 간단해 보이는 `Python 3`의 로직을 볼 때면 현타가 온다. 정말 쉽게 쉽게 작성한 코드로 보이는데 **40~50ms**가 나오고 있으니 말이다. 물론 성능에선 `C++`이 최고존엄이고, 간혹 보이는 `C#` 결과도 대부분 빠른 편이다. 간혹 보이는 node.js도 준수한 가독성에 준수한 속도를 자랑한다. 같은 문제에서 **90~100ms**로 확인된다. 이 속도는 `java`로 `stream` 없이 작성해야 나올 수 있는 수준과 비슷하다. 그러나 `Python`와 `node.js`의 로직은 훨씬 간결하다.

코드를 짧게 작성할 수 있고 가독성이 좋다는 것은 곧, 개발자의 생산성 향상으로 연결된다. 왜 Backend 시장에서 `Python`과 `node.js`가 잘 살아남아 있는지 알 수 있는 부분이다. 특히 요즘은 `Typescript`를 사용하는 `NestJS`를 사용하는 경우가 종종 보인다. 몇 년 전에만 해도 이걸 개인적으로 공부했었고, 시장에서 흔히 보이는 정도는 아니었다. 하지만 요즘 채용 공고를 보면 `NestJS`와 `FastAPI`가 은근히 많이 보인다. ~~기왕 공부한 김에 더 열심히 파볼 걸 그랬나~~

난 아직 `.Net Framework`와 `Spring Framework` 밖에 경험이 없다. 과거 개인적으로 공부했던 `NestJS`는 Hello World 수준이다. 앞으로 언어와 프레임워크에 휘둘리지(?) 않기 위해선 `Java` 외에 언어 학습에도 신경을 써야 하겠다.

### 잘못된 생각(update)  
잡생각이 아니라 잘못된 생각인 것 같다. 암만 생각해도 백엔드에서 Java가 각광 받는 것은 우리나라의 특성도 있겠지만, 성능에서 밀리지 않기 때문도 있을 것이다. 때문에 나의 무지를 개선하고자 몇 가지 조사를 했다. 그 결과 알고리즘 테스트 사이트에서 java가 느린 이유로 다음과 같은 내용을 정리할 수 있었다.  

1. 테스트 측정에 JVM이 올라오는 시간이 포함될 가능성이 있다. (추정)
2. 단발성 실행이므로 JIT 컴파일러의 최적화 이득이 없다. 
3. IO 처리 성능은 java가 타언어에 비해 비교적 느리다.  

이렇게 크게 3가지 이유로 추정된다. 1번과 2번을 고려했을 때, C++이 빠른 것은 당연하며, Python 역시 입출력 처리 기능은 더 빠르다고 알려져있다. 물론 이를 최적화하기 위해 나 역시 Java 코드에서 Scanner를 사용하지 않았고 그로 인해 꽤 빠른 속도가 나왔다. 정리하면 Backend 서버에서는 JVM과 JIT 최적화 덕분에 매우 빠른 속도와 안정성을 보여줄 수 있는 것이고, 단순한 알고리즘 테스트 용도의 실행에선 그 이점들이 모두 사라지게 되는 것이다. 물론 다양한 언어를 공부하려는 계획은 좋지만, 그 이유가 잘못 되어도 한참 잘못될 뻔했다. ~~창피하네~~ Backend는 Hot start, 알고리즘 테스트는 Cold start인 것이다.  
  
C++은 컴파일 타임이 매우 짧아 cold start 비용이 매우 낮다. Python은 JVM과 같은 초기화 과정이 없어 시작이 빠르며, 사실 Python의 내부는 상당 부분 C로 되어있다. node.js는 V8 엔진으로 되어있는데 이 역시 시작이 빠르다.  

## v3 (C# 6.0)

```C#
using System;
using System.Linq;
using System.IO;

public class Q1546 {

    public static void Main(string[] args) {
        
        int count = Console.ReadLine(); // 미사용
        
        double[] scores = Console.ReadLine().Split(' ').Select(double.Parse).ToArray();
        double max = scores.Max();
        double average = scores.Select(score -> score / max * 100).Average();

        Console.Write(average);
    }
}
```

그래서, 예전에 사용했던 `C#`을 다시 꺼내봤다. 나는 예전 회사에서 `C# 2.0` 사용하다가 나중에 레거시 시스템을 다 업그레이드 하고 그제서야 `6.0`을 사용했다. 지금은 찾아보니 `13`버전까지 존재한다. 위 코드는 `C# 6.0` 버전이다. 최근 버전에 대한 공부가 부족하니 `gemini`에게 물어봐 `10.0` 버전으로 바꿔 보라고 했는데 별 차이가 없다. 그나저나 정말 간단하고 아름답다. 내가 왜 `C#`을 좋아했는지 다시 기억 난다.

