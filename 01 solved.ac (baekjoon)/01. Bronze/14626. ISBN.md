# [ISBN](https://www.acmicpc.net/problem/14626)

> 브론즈 1

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| --------- | ----------- | ---- | ---- | --------- | --------- |
| 1 초      | 128 MB      | 8568 | 3197 | 2892      | 37.495%   |

## 문제

![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14626/1.png)

ISBN(International Standard Book Number)은 전 세계 모든 도서에 부여된 고유번호로, 국제  표준 도서번호이다. ISBN에는 국가명, 발행자 등의 정보가 담겨 있으며 13자리의 숫자로 표시된다. 그중 마지막 숫자는  체크기호로 ISBN의 정확성 여부를 점검할 수 있는 숫자이다. 이 체크기호는 일련번호의 앞에서부터 각 자리마다 가중치 1, 3,  1, 3…. 를 곱한 것을 모두 더하고, 그 값을 10으로 나눈 나머지가 0이 되도록 만드는 숫자 m을 사용한다. 수학적으로는  다음과 같다.

> ISBN이 abcdefghijklm 일 때, a+3b+c+3d+e+3f+g+3h+i+3j+k+3l+m ≡ 0 (mod 10)
>
> 즉, 체크기호 m = 10 - (a+3b+c+3d+e+3f+g+3h+i+3j+k+3l) mod 10 이다.
>
> 단, 10으로 나눈 나머지 값이 0일 경우 체크기호는 0이다.

전북대학교 중앙도서관에서 사서로 일하고 있는 영훈이는 책 정리를 하다가 개구쟁이 광현이에 의해서 ISBN이 훼손된 도서들을  발견했다. 광현이때문에 야근해야 하는 불쌍한 영훈이를 위해서 손상된 자리의 숫자를 찾아내는 프로그램을 작성해주자.

## 입력

ISBN 13자리 숫자가 입력된다. 훼손된 숫자는 *로 표시한다. (훼손된 일련번호는 체크기호를 제외한 무작위 한 자리이다.)

## 출력

훼손된 숫자 *에 알맞은 숫자를 출력한다.

​			 		

## 예제 입력 1 						

```
9788968322*73
```

## 예제 출력 1 						

```
2
```



---

# Solutions

## v1

```java
import java.io.*;

public class q14626 {
    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String isbn = br.readLine();
        char[] isbnArr = isbn.toCharArray();

        int accNum = 0;                     // 확인용 누적합 숫자
        int qNumIndex = -1;                 // '*'의 위치
        int lastNum = isbnArr[12] - '0';    // 체크기호 숫자
        int offset = 3;                     // 곱하는 숫자 3
        for (int i = 1; i < 13; i++) {

            if (isbnArr[i - 1] == '*') {
                qNumIndex = i;
                continue;
            }

            int num = isbnArr[i - 1] - '0';
            accNum += num * (i % 2 == 0 ? offset : 1);
        }
        // System.out.println("total:" + (accNum + lastNum));
        
        int qNum = (10 - ((accNum + lastNum) % 10)) % 10;
        if (qNumIndex % 2 == 0) {
            qNum = (qNum * (10 - offset)) % 10;
        }
        System.out.print(qNum);
    }
}
```

몇 번 실패하고 gpt의 도움을 받았다. 도움을 받은 부분은 26, 28 line이다.

26 line: 왜 10으로 한번 더 모듈을 계산해야 하는지 이해하지 못했다가, `(accNum + lastNum) % 10`의 값이 `0`이 되는 경우를 생각하니 이해가 되었다. 그 경우, `mod 10`을 한번 더 하지 않으면 `qNum`이 `10`이 되어버린다. 정상적으로 계산하자면 그 경우는 `0`이 나와야 맞다.

28 line: gpt의 말을 빌리자면 `3`의 역원, 즉 `7`을 먼저 곱하고 `10`으로 모듈 계산을 해야한다고 했다. 다음 예제를 보면 이해할 수 있다.

```
ex.qNum = 8
- 8을 3으로 나눠봤자 2가 나오는데, 2에 3을 곱하면 8이 아니라 6이란 것은 모두가 알고 있다. 3으로 나누는 것은 오답.
- 3으로 8을 만들 수 있는 방법은 3 * 6 = 18. 즉 6을 구해야 한다.
- 8 * 7 (3의 역원) = 56. 56에서 mod 10을하면 6이 나온다.
```



## v2 (역원 x -> brute force)

```java
import java.io.*;

public class q14626 {
    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        char[] nums = br.readLine().trim().toCharArray();

        int starIdx = -1;
        int sum = 0;        // * 제외 1~12자리 가중합
        for (int i = 0; i < 12; i++) {
            
            if (nums[i] == '*') { 
                starIdx = i + 1; 
                continue; 
            }
            
            int weight = ((i + 1) % 2 == 0) ? 3 : 1;    // 가중치 1 or 3
            sum += (nums[i] - '0') * weight;
        }

        int last = nums[12] - '0';
        int need = (10 - ((sum + last) % 10)) % 10;         // weight * x %10 == need
        int starIdxWeight = (starIdx % 2 == 0) ? 3 : 1;

        int ans = -1;
        for (int x = 0; x <= 9; x++) {
            if ((starIdxWeight * x) % 10 == need) { 
                ans = x; 
                break; 
            }
        }
        System.out.println(ans);
    }
}
```

알고보니 `v1`의 **역원 계산은 우연히 맞았던 것**이다. `3`의 역원은 `10`에서 빼서 구하는 게 아니었다. 마침 `3`의 역원은 `7`이었을 뿐이고, 이번 문제는 가중치가 `1` or `3`이었기 때문에 맞을 수 밖에 없었던 것이다. 그러니까 사실 `v1` 코드는 잘못 푼 것이다...

 `10 - offset`이 아니라, 그냥 `7`을 입력하는 게 논리적으로 맞는 풀이다.

그런데 찾아보니 역원을 구하는 공식이 복잡하고, 물론 그것을 반영하면 되겠지만 반영하더라도 적용하기에 적합하지 않다. 그 이유는 본 문제와 같은 `mod 10`에서는 역원이 존재하는 숫자는 `1`, `3`, `7`, `9`뿐이기 때문이다. 그래서 이번엔 그냥 `brute force`로 푸는 방법이다. 입력이 작기 때문에 성능의 문제가 전혀 없다.



## 결과

| 제출 번호 | 결과         | 메모리 | 시간 | 언어                                                         | 코드 길이 |
| --------- | ------------ | ------ | ---- | ------------------------------------------------------------ | --------- |
| 97388472  | 맞았습니다!! | 11520  | 72   | [Java 8](https://www.acmicpc.net/source/97388472) / [수정](https://www.acmicpc.net/submit/14626/97388472) | 1046      |
| 97387190  | 맞았습니다!! | 11476  | 68   | [Java 8](https://www.acmicpc.net/source/97387190) / [수정](https://www.acmicpc.net/submit/14626/97387190) | 1060      |

`v1`이 아주 약간 더 빠른 결과를 보인다.