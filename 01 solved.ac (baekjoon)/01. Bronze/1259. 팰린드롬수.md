# [팰린드롬수](https://www.acmicpc.net/problem/1259)

브론즈 1

| 시간 제한 | 메모리 제한 | 제출  | 정답  | 맞힌 사람 | 정답 비율 |
| :-------- | :---------- | :---- | :---- | :-------- | :-------- |
| 1 초      | 128 MB      | 86143 | 48803 | 42972     | 56.637%   |

## 문제

어떤 단어를 뒤에서부터 읽어도 똑같다면 그 단어를 팰린드롬이라고 한다. 'radar', 'sees'는 팰린드롬이다.

수도 팰린드롬으로 취급할 수 있다. 수의 숫자들을 뒤에서부터 읽어도 같다면 그 수는 팰린드롬수다. 121, 12421 등은 팰린드롬수다. 123, 1231은 뒤에서부터 읽으면 다르므로 팰린드롬수가 아니다. 또한 10도 팰린드롬수가 아닌데, 앞에 무의미한 0이 올 수 있다면 010이 되어 팰린드롬수로 취급할 수도 있지만, 특별히 이번 문제에서는 무의미한 0이 앞에 올 수 없다고 하자.

## 입력

입력은 여러 개의 테스트 케이스로 이루어져 있으며, 각 줄마다 1 이상 99999 이하의 정수가 주어진다. 입력의 마지막 줄에는 0이 주어지며, 이 줄은 문제에 포함되지 않는다.

## 출력

각 줄마다 주어진 수가 팰린드롬수면 'yes', 아니면 'no'를 출력한다.

## 예제 입력 1 복사

```
121
1231
12421
0
```

## 예제 출력 1 복사

```
yes
no
yes
```

---

# Solutions

## v1 (String)

```java
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder();

        while (br.ready()) {

            String number = br.readLine();
            if ("0".equals(number)) {
                break;
            }

            char[] number_chars = number.toCharArray();
            int left = 0;
            int right = number_chars.length - 1;
            
            while (left < right) {

                if (number_chars[left] == number_chars[right]) {
                    left++;
                    right--;
                    sb.append("yes");
                } else {
                    sb.append("no");
                }

                sb.append("\n");
            }
        }

        System.out.print(sb.toString());
    }
}

```

분명 과거에 `leetcode`에서 풀었던 문제와 유사했는데... 기억이 나지 않았다. 일단 평이하게 각 자리의 숫자(문자)를 비교해봤다. 그러나 결과는 **메모리 초과**로 실패했다. 분명 `leetcode`에서 풀었을 때 `String`이 아니라 `int`를 그대로 활용해서 해결했다. 다시 풀어보자.

## v2 (int)

```java
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder();
        

        while (br.ready()) {

            int number = Integer.parseInt(br.readLine());
            if (number == 0) break;

            boolean isPal = isPalindrome(number);
            sb.append(isPal ? "yes\n" : "no\n");
        }

        System.out.print(sb.toString());
    }

    private static boolean isPalindrome(int num) {
        
        int offset = 10;

        if (num % offset == 0) return false;
        if (num < offset) return true;

        int left = num / offset;
        int right = num % offset;
        int reverse = 0;
        while (left > 0) {

            reverse = (reverse * offset) + right;
            if (left == reverse || left / offset == reverse) {
                return true;
            }

            right = left % offset;
            left = left / offset;
        }

        return false;
    }
}
```

메모리 제한을 지켰고, 속도 `64ms`로 빠른 [결과](https://www.acmicpc.net/source/96345886)가 나왔다.

자꾸 실패하는 케이스가 있어 고전했는데, `10`과 `10 이하의 숫자`를 처리하지 않았던 것이 원인이었다. 이제 `팰린드롬` 문제를 2 개 풀었으니 앞으로는 잊지 않겠지...? 