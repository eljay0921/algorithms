# 용액

> 골드 5

| 시간 제한 | 메모리 제한 | 제출  | 정답  | 맞힌 사람 | 정답 비율 |
| --------- | ----------- | ----- | ----- | --------- | --------- |
| 1 초      | 128 MB      | 53881 | 21063 | 16165     | 37.669%   |

## 문제

KOI 부설 과학연구소에서는 많은 종류의 산성 용액과 알칼리성 용액을 보유하고 있다. 각 용액에는 그 용액의 특성을  나타내는 하나의 정수가 주어져있다. 산성 용액의 특성값은 1부터 1,000,000,000까지의 양의 정수로 나타내고, 알칼리성  용액의 특성값은 -1부터 -1,000,000,000까지의 음의 정수로 나타낸다.

같은 양의 두 용액을 혼합한 용액의 특성값은 혼합에 사용된 각 용액의 특성값의 합으로 정의한다. 이 연구소에서는 같은 양의 두 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들려고 한다. 

예를 들어, 주어진 용액들의 특성값이 [-99, -2, -1, 4, 98]인 경우에는 특성값이 -99인 용액과 특성값이  98인 용액을 혼합하면 특성값이 -1인 용액을 만들 수 있고, 이 용액의 특성값이 0에 가장 가까운 용액이다. 참고로, 두 종류의 알칼리성 용액만으로나 혹은 두 종류의 산성 용액만으로 특성값이 0에 가장 가까운 혼합 용액을 만드는 경우도 존재할 수 있다.

산성 용액과 알칼리성 용액의 특성값이 정렬된 순서로 주어졌을 때, 이 중 두 개의 서로 다른 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액을 찾는 프로그램을 작성하시오.

## 입력

첫째 줄에는 전체 용액의 수 N이 입력된다. N은 2 이상 100,000 이하의 정수이다. 둘째 줄에는 용액의  특성값을 나타내는 N개의 정수가 빈칸을 사이에 두고 오름차순으로 입력되며, 이 수들은 모두 -1,000,000,000 이상  1,000,000,000 이하이다. N개의 용액들의 특성값은 모두 서로 다르고, 산성 용액만으로나 알칼리성 용액만으로 입력이  주어지는 경우도 있을 수 있다.

## 출력

첫째 줄에 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액의 특성값을 출력한다. 출력해야 하는 두 용액은  특성값의 오름차순으로 출력한다. 특성값이 0에 가장 가까운 용액을 만들어내는 경우가 두 개 이상일 경우에는 그 중 아무것이나  하나를 출력한다.

​			 		

## 예제 입력 1 						

```
5
-99 -2 -1 4 98
```

## 예제 출력 1 						

```
-99 98
```

## 예제 입력 2 						

```
4
-100 -2 -1 103
```

## 예제 출력 2 						

```
-2 -1
```

---

# Solutions

## v1 (two pointers)

```java
import java.io.*;
import java.util.*;

public class q2467 {
    
    public static void main(String[] args) throws IOException {

        // (1) 입력 및 전처리
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int count = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());
        int[] nums = new int[count];
        for (int i = 0; i < count; i++) {
            nums[i] = Integer.parseInt(st.nextToken());
        }

        // (2) processing
        int left = 0;
        int right = count - 1;
        int minSum = Integer.MAX_VALUE;
        int[] result = new int[2];
        while (left < right) {

            int sum = nums[left] + nums[right];
            if (sum == 0) {
                result[0] = nums[left];
                result[1] = nums[right];
                break;
            }

            if (Math.abs(sum) < minSum) {
                minSum = Math.abs(sum);
                result[0] = nums[left];
                result[1] = nums[right];
            }
            
            if (sum < 0) {
                left++;
            } else {
                right--;
            }

        }

        System.out.println(result[0] + " " + result[1]);
    }
}

```

첫 번째 솔루션은 늘 그래왔듯 **생각나는 대로** 풀었다. 근데 왜 맞았지? 간단하게 생각했을 때, `two pointers`로 좁혀나가면 된다고 생각했다. 왜냐면 문제에서 제시하듯, **이미 숫자는 정렬이 되어있기 때문**이다. 그래서 굳이 모든 경우의 수를 볼 필요는 없다고 생각했는데, 맞는 방법이었다. 



## v2 (리팩토링)

```java
import java.io.*;
import java.util.*;

public class q2467 {
    
    public static void main(String[] args) throws IOException {

        // (1) 입력 및 전처리
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int count = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());
        int[] nums = new int[count];
        for (int i = 0; i < count; i++) {
            nums[i] = Integer.parseInt(st.nextToken());
        }

        // (2) processing
        int left = 0;
        int right = count - 1;
        int minSum = Integer.MAX_VALUE;
        int[] result = new int[2];
        while (left < right) {

            int sum = nums[left] + nums[right];
            if (Math.abs(sum) < minSum) {
                minSum = Math.abs(sum);
                result[0] = nums[left];
                result[1] = nums[right];

                if (minSum == 0) {
                    break;
                }
            }
            
            if (sum < 0) {
                left++;
            } else {
                right--;
            }

        }

        System.out.println(result[0] + " " + result[1]);
    }
}

```

별다른 알고리즘은 아니고 `sum == 0` 체크 부분을 아래 if에 포함시켜 리팩토링 함으로써 중복 코드를 줄였다.



## v3 (Python)

```python
"""백준 2467"""

def main() :
    """백준 2467 풀이"""
    count = int(input())
    nums = list(map(int, (input().split())))

    left = 0
    right = count - 1
    result = []
    min_sum = float('inf')

    while left < right :
        cur_sum = nums[left] + nums[right]

        if abs(cur_sum) < min_sum :
            result = (nums[left], nums[right])
            min_sum = abs(cur_sum)
            if min_sum == 0 :
                break

        if cur_sum < 0 :
            left += 1
        else :
            right -= 1

    print(result[0], result[1])

main()

```

```python
"""백준 2467"""

def main() :
    """백준 2467 풀이"""
    count = int(input())
    nums = list(map(int, (input().split())))

    left = 0
    right = count - 1
    result = (0, 0)
    min_sum = float('inf')

    while left < right :
        cur_sum = nums[left] + nums[right]

        if abs(cur_sum) < min_sum :
            result = (nums[left], nums[right])
            min_sum = abs(cur_sum)
            if min_sum == 0 :
                break

        if cur_sum < 0 :
            left += 1
        else :
            right -= 1

    print(*result)

if __name__ == "__main__" :
    main()

```

아래는 `chatGPT`의 도움으로 좀 더 **파이썬 스타일(Pythonic)**에 맞게 수정한 버전이다. 난 아직 파이썬이 어색하다.

- result 변수 초기화 부분 `result = (0, 0)`
- `print()`에서 result 언패킹 연산자 적용 `print(*result)`
- 모듈로 `import`하는 경우에 실행되는 것을 방어하기 위한 로직 `if __name__ == "__main__" :`



## 정리

이미 **정렬된 입력 값**에 대한 최적 값을 찾는 문제이므로` two pointers`가 적합한 solution이다. 만약 정렬이 되어있지 않은 경우라면? 정렬한 뒤 two pointers를 적용하자...



## 결과

![image-20250725182343016](C:\00-dev-workspace\algorithms\01 solved.ac (baekjoon)\03. Gold\assets\image-20250725182343016.png)