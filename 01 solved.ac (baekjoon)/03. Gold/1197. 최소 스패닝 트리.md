# [최소 스패닝 트리](https://www.acmicpc.net/problem/1197)

> 골드 4

| 시간 제한 | 메모리 제한 | 제출   | 정답  | 맞힌 사람 | 정답 비율 |
| --------- | ----------- | ------ | ----- | --------- | --------- |
| 1 초      | 128 MB      | 113058 | 40750 | 23904     | 37.808%   |

## 문제

그래프가 주어졌을 때, 그 그래프의 최소 스패닝 트리를 구하는 프로그램을 작성하시오.

최소 스패닝 트리는, 주어진 그래프의 모든 정점들을 연결하는 부분 그래프 중에서 그 가중치의 합이 최소인 트리를 말한다.

## 입력

첫째 줄에 정점의 개수 V(1 ≤ V ≤ 10,000)와 간선의 개수 E(1 ≤ E ≤ 100,000)가 주어진다. 다음 E개의 줄에는 각 간선에 대한 정보를 나타내는 세 정수 A, B, C가 주어진다. 이는 A번 정점과 B번 정점이 가중치  C인 간선으로 연결되어 있다는 의미이다. C는 음수일 수도 있으며, 절댓값이 1,000,000을 넘지 않는다.

그래프의 정점은 1번부터 V번까지 번호가 매겨져 있고, 임의의 두 정점 사이에 경로가 있다. 최소 스패닝 트리의 가중치가  -2,147,483,648보다 크거나 같고, 2,147,483,647보다 작거나 같은 데이터만 입력으로 주어진다.

## 출력

첫째 줄에 최소 스패닝 트리의 가중치를 출력한다.

​			 		

## 예제 입력 1 						

```
3 3
1 2 1
2 3 2
1 3 3
```

## 예제 출력 1 						

```
3
```



---

# Solutions

문제를 봤을 때, 너비 우선 탐색과 깊이 우선 탐색 중 고민을 했지만, 어쨌거나 모든 탐색을 끝마쳐 봐야 최종적으로 어떤 길이가 더 짧은지 알 수 있을 거라고 판단했다. 하지만 뜻대로 풀리지 않았고, 애초에 자료구조부터 다시 고민해야했다. 결국 정보를 검색하게 되었고, 이 문제는 가중치 기반의 알고리즘이 필요하다.

## v1 (prim)

```java
import java.io.*;
import java.util.*;

public class q1197 {
    public static void main(String[] args) throws IOException {

        // 입력 -> 간선 정보
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int nodeCount = Integer.parseInt(st.nextToken());
        int lineCount = Integer.parseInt(st.nextToken());

        ArrayList<PathInfo>[] pathListArray = new ArrayList[nodeCount + 1];
        for (int i = 1; i < nodeCount + 1; i++) {
            pathListArray[i] = new ArrayList<PathInfo>();
        }

        for (int i = 0; i < lineCount; i++) {
            st = new StringTokenizer(br.readLine());
            int node1 = Integer.parseInt(st.nextToken());
            int node2 = Integer.parseInt(st.nextToken());
            int weight = Integer.parseInt(st.nextToken());

            pathListArray[node1].add(new PathInfo(node2, weight));
            pathListArray[node2].add(new PathInfo(node1, weight));
        }

        // processing: prim
        boolean[] visited = new boolean[nodeCount + 1];
        int result = prim(pathListArray, visited, 1);

        // 출력
        System.out.print(result);
    }

    private static int prim(ArrayList<PathInfo>[] paths, boolean[] visited, int start) {

        PriorityQueue<PathInfo> pq = new PriorityQueue<>();
        pq.add(new PathInfo(start, 0));

        int totalWeight = 0;
        while (pq.isEmpty() == false) {

            PathInfo current = pq.poll();
            if (visited[current.to] == false) {
                visited[current.to] = true;
                totalWeight += current.weight;

                for (PathInfo next : paths[current.to]) {
                    if (visited[next.to] == false) {
                        pq.offer(next);
                    }
                }
            }
        }

        return totalWeight;
    }

    private static class PathInfo implements Comparable {
        int to;
        int weight;

        public PathInfo(int pTo, int pWeight) {
            to = pTo;
            weight = pWeight;
        }

        @Override
        public int compareTo(Object o) {
            return this.weight - ((PathInfo) o).weight;
        }
    }
}

```

`v1`는 `prim` 알고리즘을 적용한 솔루션이다. `prim`은 **노드(정점) 중심 알고리즘**이다. 소스 코드를 보면, 처음 고민했던 탐색 알고리즘과 구조 측면에서는 같다고 볼 수 있다. 차이점은 2가지가 있는데, **가중치** 정보를 관리하기 위해 **class**(`PathInfo`)를 하나 생성한 것이 첫 번째. 그리고 그 **가중치에 따라 우선순위를 다룰** 수 있도록 `PriorityQueue`를 사용한 것이 두 번째다. 그리고 `prim` 알고리즘 **시작 노드를** `1`로 진행했는데, 어디서 시작하든 연결된 간선의 가중치가 작기만 하면 되는 것이므로 시작 노드의 위치는 상관없다. 속도는 `532ms`로 다른 사람들의 답안과 비슷하다.

## v2 (kruskal: union-find)

```java
import java.io.*;
import java.util.*;

public class q1197_kruskal {
    public static void main(String[] args) throws IOException {
        // 입력 -> 간선 정보
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int nodeCount = Integer.parseInt(st.nextToken());
        int lineCount = Integer.parseInt(st.nextToken());

        ArrayList<PathInfo> pathList = new ArrayList<PathInfo>();
        for (int i = 0; i < lineCount; i++) {
            st = new StringTokenizer(br.readLine());
            int node1 = Integer.parseInt(st.nextToken());
            int node2 = Integer.parseInt(st.nextToken());
            int weight = Integer.parseInt(st.nextToken());

            pathList.add(new PathInfo(node1, node2, weight));
        }

        // 가중치 기준 정렬
        Collections.sort(pathList);

        // processing: union-find
        int[] parents = new int[nodeCount + 1];
        for (int i = 1; i < nodeCount + 1; i++) {
            parents[i] = i;
        }

        int resultWeight = 0;
        for (PathInfo info : pathList) {
            if (union(info.from, info.to, parents)) {
                resultWeight += info.weight;
            }
        }

        // 출력
        System.out.print(resultWeight);
    }

    private static boolean union(int from, int to, int[] parents) {
        int rootA = find(from, parents);
        int rootB = find(to, parents);

        if (rootA == rootB) return false;

        parents[rootB] = rootA;
        return true;
    }

    private static int find(int node, int[] parents) {
        if (node != parents[node]) {
            parents[node] = find(parents[node], parents);
        }
        return parents[node];
    }

    private static class PathInfo implements Comparable {
        int from;
        int to;
        int weight;

        public PathInfo(int pFrom, int pTo, int pWeight) {
            from = pFrom;
            to = pTo;
            weight = pWeight;
        }

        @Override
        public int compareTo(Object o) {
            return this.weight - ((PathInfo) o).weight;
        }
    }
}

```

이번에는 간선 중심의 알고리즘 `kruskal`이다. 결과는 `484ms`로 `prim` 알고리즘 보다 조금 더 빠르다. 사실 처음엔 잘 이해하지 못했고, 반복해서 소스 코드를 살펴보니 조금씩 이해됐다. 이건 내가 직접 풀어낸 코드가 아니라, `chatGPT`를 통해 푼 내용이기 때문에 반복 학습이 필요하겠다.

`v1 (prim)` 버전과 다른 점이라면, 간선 정보를 위해 `from`, `to`, `weight`를 모두 관리하는 점과 더불어 사이클이 발생하지 않도록 `union-find` 로직이 들어갔다는 점이다. `v1`, `v2` 모두 공통적으로 **오름차순 정렬**을 통해 가장 저렴한 경로를 찾고 있다. 



## 정리

노드(정점)의 수가 적거나 간선이 복잡할 경우라면 `prim` 알고리즘, 반대로 간선이 적거나 노드(정점)이 많은 경우엔 `kruskal`이 적합하다. 개인적으로 가독성은 `prim`이 낫다고 보지만, **속도 차이가 분명**하므로 상황에 따라 적합한 알고리즘을 선택할 필요는 있겠다.



## 결과

| 제출 번호 | 결과         | 메모리 | 시간 | 언어                                                         | 코드 길이 | 제출한 시간                    |
| --------- | ------------ | ------ | ---- | ------------------------------------------------------------ | --------- | ------------------------------ |
| 97093808  | 맞았습니다!! | 49492  | 484  | [Java 8](https://www.acmicpc.net/source/97093808) / [수정](https://www.acmicpc.net/submit/1197/97093808) | 2183      | [3분 전](javascript:void(0);)  |
| 97091998  | 맞았습니다!! | 55888  | 532  | [Java 8](https://www.acmicpc.net/source/97091998) / [수정](https://www.acmicpc.net/submit/1197/97091998) | 2270      | [34분 전](javascript:void(0);) |



