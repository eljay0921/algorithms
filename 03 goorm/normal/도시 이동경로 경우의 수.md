# [도시 이동경로 경우의 수](https://level.goorm.io/exam/355867/%EB%8F%84%EC%8B%9C-%EC%9D%B4%EB%8F%99%EA%B2%BD%EB%A1%9C-%EA%B2%BD%EC%9A%B0%EC%9D%98-%EC%88%98/quiz/1)

![image-20250909112049449](assets/image-20250909112049449.png)

---

## Solution

### v1

```java
import java.io.*;

class Main {
    static final int MOD = 1000000007; // 10^9 + 7
    
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        
        if (n == 1) {
            System.out.println(1);
        } else {
            // 모듈러 지수 연산으로 2^(n-2) % MOD 계산
            long result = modPow(2, n - 2, MOD);
            System.out.println(result);
        }
    }
    
    // 모듈러 지수 연산: base^exp % mod
    static long modPow(long base, long exp, long mod) {
        long result = 1;
        base %= mod;
        
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        
        return result;
    }
}

// cities: 5

// 1: 1
// 2: 1
// 3: 2 
// 	(1 -> 2) -> 3

// 4: 4
// 	(1 -> 2 -> 3) -> 4

// 5: 8
// 	(1 -> 2 -> 3 -> 4) -> 5

// dp[5] = 8
// dp[6] = 16
```

처음에는 dp로 풀려고 패턴을 작성했다. 그러다보니 규칙이 보였는데, 그 수식은 `2^(n - 2)`였다. 그러나 한가지 문제가 있다면 Math.pow(2, n - 2)를 계산하는 결과 값이 너무 크게 나온다는 것이다. (10^9까지 커버해야 한다)

그래서 문제의 출력 부분을 보면 `10^9 + 7`로 나눈 값을 활용하라고 안내 하고 있다. 이를 위해서 모듈러 연산이 필요한데, 이는 `claude.ai`의 도움을 받았다. 아직 이 알고리즘에 대한 연습이 부족하다. 단번에 이해가 되진 않았지만 반복하다 보면 체득하게 되겠지.

